import streamlit as st
import pandas as pd
import uuid
from io import StringIO
import os # Mantido por boa pr√°tica, embora n√£o use mais o m√≥dulo os para o DB

# --- Configura√ß√µes Iniciais ---
st.set_page_config(layout="wide", page_title="Otimizador de Rotas com Corre√ß√£o Manual")

# Vari√°veis globais simuladas
APP_ID = "rota_flow_simulacao" 
app_id = APP_ID

# --- 1. Inicializa√ß√£o do Estado de Sess√£o (Substitui o DB) ---
def initialize_session_state():
    """
    Inicializa o dicion√°rio de corre√ß√µes no estado de sess√£o do Streamlit.
    Este dicion√°rio s√≥ persiste enquanto o aplicativo estiver aberto.
    """
    if 'fixed_coords' not in st.session_state:
        # { "Endere√ßo Exato (Destination Address)": {"lat": 12.345, "lng": -56.789} }
        st.session_state['fixed_coords'] = {}
        st.info("Dicion√°rio de corre√ß√µes iniciado. Os dados n√£o ser√£o salvos permanentemente.")

# --- 2. Fun√ß√µes de Manipula√ß√£o do Dicion√°rio Fixo (Usando Session State) ---
# NOTE: N√£o h√° mais fun√ß√µes save/get para o banco de dados.
# O dicion√°rio st.session_state['fixed_coords'] √© a fonte de verdade local.

# --- 3. Fun√ß√£o de Processamento de Dados (Foco na Corre√ß√£o) ---
def process_data(df: pd.DataFrame, fixed_coords_dict: dict):
    """
    Processa o DataFrame, aplica corre√ß√µes manuais usando 'Destination Address' como chave.
    """
    st.header("1. Detalhes do Processamento")

    # 1. Valida√ß√£o de Colunas M√≠nimas
    required_cols = ['Destination Address', 'Latitude', 'Longitude']
    if not all(col in df.columns for col in required_cols):
        st.error(f"O arquivo deve conter as colunas: {required_cols}.")
        st.info(f"Colunas encontradas: {df.columns.tolist()}")
        return None

    # Garantir que Lat/Lng sejam num√©ricos (for√ßa coerc√£o para NaN se houver erro)
    df['Latitude'] = pd.to_numeric(df['Latitude'], errors='coerce')
    df['Longitude'] = pd.to_numeric(df['Longitude'], errors='coerce')
    
    st.subheader("APLICA√á√ÉO DE CORRE√á√ïES MANUAIS (Ponto Cr√≠tico)")
    st.warning("A correspond√™ncia √© feita usando a coluna **'Destination Address'** como chave EXATA (caracter por caracter).")

    # --- L√ìGICA DE CORRE√á√ÉO ---
    
    # 1. Mapeamento: Aplica o dicion√°rio de corre√ß√£o na coluna de endere√ßo.
    df[['Fixed_Lat', 'Fixed_Lng']] = df['Destination Address'].map(fixed_coords_dict).apply(
        lambda x: pd.Series(x) if isinstance(x, dict) else pd.Series([None, None])
    )
    
    # 2. Priorizar a corre√ß√£o manual sobre os valores existentes (combine_first)
    df['Latitude'] = df['Fixed_Lat'].combine_first(df['Latitude'])
    df['Longitude'] = df['Fixed_Lng'].combine_first(df['Longitude'])
    
    # --- FIM DA L√ìGICA DE CORRE√á√ÉO ---
    
    # Contar quantas corre√ß√µes foram aplicadas
    correcoes_aplicadas = df['Fixed_Lat'].notnull().sum()
    st.success(f"‚úÖ {correcoes_aplicadas} corre√ß√µes manuais do Dicion√°rio Fixo aplicadas com sucesso.")

    # 3. Identificar pontos sem Lat/Lng v√°lida
    invalid_rows = df[df['Latitude'].isna() | df['Longitude'].isna()]
    if not invalid_rows.empty:
        st.error(f"üö® {len(invalid_rows)} registros permanecem com Lat/Lng inv√°lida ap√≥s a corre√ß√£o.")
        st.dataframe(invalid_rows[['Destination Address', 'Latitude', 'Longitude']].head(5))
        st.info("Estes endere√ßos precisam ser corrigidos manualmente na Aba 2 para serem roteirizados.")
    
    # 4. Preparar o DataFrame para Download/Pr√≥xima Etapa
    df = df.drop(columns=['Fixed_Lat', 'Fixed_Lng'])
    
    if 'Routing_ID' not in df.columns:
        df['Routing_ID'] = [str(uuid.uuid4()) for _ in range(len(df))]

    st.subheader("Sa√≠da Final")
    st.dataframe(df.head())
    
    # Bot√£o de Download
    csv = df.to_csv(index=False)
    st.download_button(
        label="Download Dados Processados (CSV)",
        data=csv,
        file_name='dados_processados_com_correcao.csv',
        mime='text/csv',
    )
    
    return df

# --- 4. Interface do Streamlit (Fun√ß√£o Principal) ---

def main():
    st.title("üó∫Ô∏è Pr√©-Roteirizador & Dicion√°rio Fixo")
    
    # Inicializa o dicion√°rio de corre√ß√µes (sempre executa no in√≠cio)
    initialize_session_state()

    # O c√≥digo come√ßa a renderizar a interface aqui.
    tab1, tab2 = st.tabs(["1. Processar Planilha (Corre√ß√£o)", "2. Gerenciar Dicion√°rio Fixo"])

    # --- TAB 1: Processamento ---
    with tab1:
        st.header("1. Upload e Processamento de Dados")
        
        uploaded_file = st.file_uploader(
            "Selecione o arquivo CSV/Excel para processar.",
            type=["csv", "xlsx"]
        )
        st.info("O arquivo deve conter as colunas: **'Destination Address'**, **'Latitude'** e **'Longitude'**.")

        if uploaded_file:
            try:
                # Determinar o tipo de arquivo
                if uploaded_file.name.endswith('.csv'):
                    data = uploaded_file.getvalue().decode('utf-8')
                    df = pd.read_csv(StringIO(data))
                else:
                    df = pd.read_excel(uploaded_file)
                
                st.success(f"Arquivo '{uploaded_file.name}' lido com sucesso. Total de {len(df)} linhas.")

                # Executa o processamento
                process_data(df.copy(), st.session_state['fixed_coords'])
                
            except Exception as e:
                st.error(f"Erro ao ler ou processar o arquivo. Verifique se o formato e as colunas est√£o corretos. Erro: {e}")

    # --- TAB 2: Gerenciamento do Dicion√°rio Fixo ---
    with tab2:
        st.header("2. Gerenciar Dicion√°rio Fixo de Lat/Lng")
        
        # 2.1 Adicionar/Atualizar Corre√ß√£o
        st.subheader("2.1 Adicionar Nova Corre√ß√£o")
        st.info("Use o conte√∫do **EXATO** da coluna 'Destination Address' como chave para garantir a correspond√™ncia.")
        with st.form("form_add_correction"):
            new_address = st.text_input("Endere√ßo Exato (Valor da coluna 'Destination Address')", placeholder="Ex: Rua Tal, 123, Bairro")
            new_lat = st.text_input("Latitude Corrigida", placeholder="Use ponto '.' como separador. Ex: -23.5505")
            new_lng = st.text_input("Longitude Corrigida", placeholder="Use ponto '.' como separador. Ex: -46.6333")
            submitted = st.form_submit_button("Adicionar Corre√ß√£o") # Removido 'e Salvar' pois n√£o h√° DB

            if submitted:
                if not new_address:
                    st.warning("Preencha o Endere√ßo para adicionar a corre√ß√£o.")
                else:
                    try:
                        # 1. Limpeza: Remove espa√ßos e substitui v√≠rgula por ponto (para flexibilidade)
                        cleaned_lat = new_lat.strip().replace(',', '.')
                        cleaned_lng = new_lng.strip().replace(',', '.')

                        # 2. Convers√£o: Tenta converter para float
                        lat_val = float(cleaned_lat)
                        lng_val = float(cleaned_lng)
                        
                        # 3. Sucesso: Adiciona/Atualiza o dicion√°rio no estado de sess√£o
                        st.session_state['fixed_coords'][new_address] = {'lat': lat_val, 'lng': lng_val}
                        
                        st.success(f"Corre√ß√£o salva LOCALMENTE com sucesso para: '{new_address}'")
                        st.experimental_rerun() # Recarrega para atualizar a visualiza√ß√£o da tabela

                    except ValueError:
                        # 4. Falha: Exibe a mensagem de erro
                        st.error("Latitude e Longitude devem ser n√∫meros v√°lidos. Verifique se usou ponto (.) ou se h√° caracteres estranhos.")

        # 2.2 Visualizar/Excluir Dicion√°rio
        st.subheader("2.2 Visualizar Dicion√°rio Atual (Local)")
        st.info("Este dicion√°rio √© LOCAL e ser√° perdido se voc√™ fechar o navegador.")
        
        fixed_coords = st.session_state['fixed_coords']
        if fixed_coords:
            # Converte para DataFrame para visualiza√ß√£o f√°cil
            data_list = []
            for address, coords in fixed_coords.items():
                data_list.append({
                    "Endere√ßo (Chave Exata - 'Destination Address')": address,
                    "Latitude Fixa": coords['lat'],
                    "Longitude Fixa": coords['lng'],
                })
            
            df_fixed = pd.DataFrame(data_list)
            st.dataframe(df_fixed, use_container_width=True, height=300)

            # Op√ß√£o de Excluir
            address_to_delete = st.selectbox(
                "Selecione o endere√ßo para remover (opcional):",
                [""] + list(fixed_coords.keys())
            )
            
            if st.button("Remover Corre√ß√£o Selecionada"):
                if address_to_delete and address_to_delete in fixed_coords:
                    del st.session_state['fixed_coords'][address_to_delete]
                    st.success(f"Corre√ß√£o para '{address_to_delete}' removida com sucesso. ")
                    st.experimental_rerun()
                elif address_to_delete:
                    st.warning("Endere√ßo n√£o encontrado no dicion√°rio.")
        else:
            st.info("O dicion√°rio de corre√ß√µes fixas est√° vazio.")
            
if __name__ == '__main__':
    main()
